n %% 10000
n %% 100000
n %% 100000 - n %% 10000
(n %% 100000 - n %% 10000) 10000
(n %% 100000 - n %% 10000) /10000
order <- 1:nchar(n)
(n %% 1000000 - n %% 100000) / 100000
(n %% 10000 - n %% 1000) / 1000
order <- nchar(n):1
(n %% 10^order) - (n %% 10^(order - 1))
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1))/(10^order(-1)))
})
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
n <- 5362
order <- nchar(n):1
digits <-
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
-digits
rev(digits)
rev(digits) == digits
all(rev(digits) == digits)
n <- 4444
order <- nchar(n):1
digits <-
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
all(rev(digits) == digits)
n <- 1001
order <- nchar(n):1
digits <-
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
all(rev(digits) == digits)
n <- 10901
order <- nchar(n):1
digits <-
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
all(rev(digits) == digits)
n <- c(10901, 45632)
order <- nchar(n):1
# PROJECT EULER EXERCISE 4:
#
# A palindromic number reads the same both ways.
# The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
#
# Find the largest palindrome made from the product of two 3-digit numbers.
palindrome <- function(n) {
order <- nchar(n):1
digits <-
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
all(rev(digits) == digits)
}
sapply(1:100, palindrome)
sapply(1:10000, palindrome)
seq.int(999^2, 100^2, by = 1)
seq.int(999^2, 100^2, by = -1)
vec <- vector()
c(vec, 4)
any(vec)
euler_four <- function(nums = seq.int(100^2, 999^2, by = -1)) {
index <- 1
repeat {
if(palindrome(nums[index])) break
index <- index + 1
}
nums[index]
}
euler_four()
euler_four <- function(nums = seq.int(999^2, 100^2, by = -1)) {
index <- 1
repeat {
if(palindrome(nums[index])) break
index <- index + 1
}
nums[index]
}
euler_four()
# PROJECT EULER EXERCISE 4:
#
# A palindromic number reads the same both ways.
# The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
#
# Find the largest palindrome made from the product of two 3-digit numbers.
palindrome <- function(n) {
order <- nchar(n):1
digits <-
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
all(rev(digits) == digits)
}
euler_four <- function(nums = seq.int(999^2, 100^2, by = -1)) {
index <- 1
repeat {
if(palindrome(nums[index])) break
index <- index + 1
}
nums[index]
}
euler_four()
1:10
1:10*1:10
combn(1:10)
combn(1:10, m = 10)
combn(1:10, m = 1)
crossprod(1:3, 1:3)
sapply(1:10, function(x) x*1:10)
lapply(1:10, function(x) x*1:10)
sapply(1:10, function(x) x*1:10)
as.vector(sapply(1:10, function(x) x*1:10))
sort(as.vector(sapply(1:10, function(x) x*1:10)))
sort(as.vector(sapply(1:10, function(x) x*1:10)), decreasing = T)
sort(as.vector(sapply(100:999, function(x) x*100:999)), decreasing = T)
euler_four <- function(nums = as.vector(sapply(100:999, function(x) x*100:999))) {
nums <- sort(nums, decreasing = T)
index <- 1
repeat {
if(palindrome(nums[index])) break
index <- index + 1
}
nums[index]
}
euler_four()
sapply(100:999, function(x) x*100:999)
sapply(100:999, function(x) x*100:999)
vapply(100:999, function(x) x*100:999, c())
vapply(100:999, function(x) x*100:999, c(1))
vapply(100:999, function(x) x*100:999, "")
vapply(100:999, function(x) x*100:999, numeric)
vapply(100:999, function(x) x*100:999, c(numeric))
vapply(100:999, function(x) x*100:999, identity)
euler_four()
# PROJECT EULER EXERCISE 4:
#
# A palindromic number reads the same both ways.
# The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
#
# Find the largest palindrome made from the product of two 3-digit numbers.
palindrome <- function(n) {
order <- nchar(n):1
digits <-
sapply(order, function(order) {
((n %% 10^order) - (n %% 10^(order - 1)))/(10^(order - 1))
})
all(rev(digits) == digits)
}
euler_four <- function(nums = as.vector(sapply(100:999, function(x) x*100:999))) {
nums <- sort(nums, decreasing = T)
index <- 1
repeat {
if(palindrome(nums[index])) break
index <- index + 1
}
nums[index]
}
euler_four()
euler_four(1000000:1)
# PROJECT EULER EXERCISE 5:
#
# 2520 is the smallest number that can be divided by each of the numbers
# from 1 to 10 without any remainder.
#
# What is the smallest positive number that is evenly divisible by all
# of the numbers from 1 to 20?
primes <- function(n) {
n <- floor(n)
primes <- c(FALSE, rep(TRUE, n-1))
max_p <- floor(sqrt(n))
p <- 2L
while(p <= max_p) {
primes[seq.int(2L*p, n, p)] <- FALSE
p <- min(subset(which(primes), which(primes) > p))
}
which(primes)
}
euler_three <- function(n = 600851475143) {
primenums <- primes(sqrt(n))
factors <- primenums[which(n %% primenums == 0)]
while(n / prod(factors) > 1) {
newnum <- n/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
sort(factors)
}
# PROJECT EULER EXERCISE 5:
#
# 2520 is the smallest number that can be divided by each of the numbers
# from 1 to 10 without any remainder.
#
# What is the smallest positive number that is evenly divisible by all
# of the numbers from 1 to 20?
primes <- function(n) {
n <- floor(n)
primes <- c(FALSE, rep(TRUE, n-1))
max_p <- floor(sqrt(n))
p <- 2L
while(p <= max_p) {
primes[seq.int(2L*p, n, p)] <- FALSE
p <- min(subset(which(primes), which(primes) > p))
}
which(primes)
}
euler_three <- function(n = 600851475143) {
primenums <- primes(sqrt(n))
factors <- primenums[which(n %% primenums == 0)]
while(n / prod(factors) > 1) {
newnum <- n/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
sort(factors)
}
euler_three(20)
euler_five <- function(n = 20) {
primenums <- primes(sqrt(n))
factors <- primenums[which(n %% primenums == 0)]
while(n / prod(factors) > 1) {
newnum <- n/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
sort(factors)
}
euler_five()
euler_five(19)
euler_five(15)
primenums(20)
primes(20)
data.frame(primes(20))
df <- data.frame()
names(df) <- primes(20)
df <- data.frame(ncols = 8)
df <- data.frame(matrix(ncol = 8))
df
df <- data.frame(matrix(nrow = 0, ncol = 8))
df
names(df) <- primes(20)
df
euler_five(20)
sum(euler_five(20) == 2)
sum(euler_five(20) == 3)
sum(euler_five(20) == 3)
sapply(primes(20), function(x) sum(euler_five(20) == x))
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 1:n){
primenums <- primes(sqrt(n))
factors <- primenums[which(n %% primenums == 0)]
while(n / prod(factors) > 1) {
newnum <- n/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
}
euler_five()
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 1:n){
primenums <- primes(sqrt(n))
factors <- primenums[which(n %% primenums == 0)]
while(n / prod(factors) > 1) {
newnum <- n/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
return(df)
}
euler_five()
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 1:n){
primenums <- primes(sqrt(i))
factors <- primenums[which(i %% primenums == 0)]
while(i / prod(factors) > 1) {
newnum <- i/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
return(df)
}
euler_five()
sapply(euler_five(), sum)
sapply(euler_five(), max)
prod(sapply(euler_five(), max))
sapply(euler_five(), max)
vector(sapply(euler_five(), max))
as.vector(sapply(euler_five(), max))
prod(as.vector(sapply(euler_five(), max)))
euler_five(10)
names(euler_five(10))
sapply(euler_five(10), function(x){
as.integer(names(x))^max(x)
})
sapply(euler_five(10), function(x){
as.integer(names(x))
})
sapply(euler_five(10), function(x){
names(x)
})
sapply(euler_five(10), function(x){
sum(x)
})
sapply(euler_five(10), function(x){
max(x)
})
sapply(euler_five(10), function(x, y=names(x)){
as.numeric(y)^max(x)
})
sapply(euler_five(10), function(x, y=names(x)){
y
})
euler_five()
names(euler_five())
as.integer(names(euler_five()))
mapply(^, 1:3, 1:3)
mapply(`^, 1:3, 1:3)
mapply(~^, 1:3, 1:3)
mapply(~^, 1:3, 1:3)
mapply(, 1:3, 1:3)
1
``
`
mapply(function(x,y) x^y, 1:3, 1:3)
sapply(euler_five(), max)
as.numeric(names(euler_five()))
mapply(function(x,y) x^y, as.numeric(names(euler_five())), sapply(euler_five(), max))
prod(mapply(function(x,y) x^y, as.numeric(names(euler_five())), sapply(euler_five(), max)))
prod(mapply(function(x,y) x^y, as.numeric(names(euler_five(10))), sapply(euler_five(10), max)))
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 1:n){
primenums <- primes(sqrt(i))
factors <- primenums[which(i %% primenums == 0)]
while(i / prod(factors) > 1) {
newnum <- i/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
prod(mapply(function(x,y) x^y, as.numeric(names(df)), sapply(df, max)))
}
euler_five(10)
euler_five(30)
euler_five()
# PROJECT EULER EXERCISE 5:
#
# 2520 is the smallest number that can be divided by each of the numbers
# from 1 to 10 without any remainder.
#
# What is the smallest positive number that is evenly divisible by all
# of the numbers from 1 to 20?
primes <- function(n) {
n <- floor(n)
primes <- c(FALSE, rep(TRUE, n-1))
max_p <- floor(sqrt(n))
p <- 2L
while(p <= max_p) {
primes[seq.int(2L*p, n, p)] <- FALSE
p <- min(subset(which(primes), which(primes) > p))
}
which(primes)
}
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 1:n){
primenums <- primes(sqrt(i))
factors <- primenums[which(i %% primenums == 0)]
while(i / prod(factors) > 1) {
newnum <- i/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
prod(mapply(function(x,y) x^y, as.numeric(names(df)), sapply(df, max)))
}
euler_five()
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 2:n){
primenums <- primes(sqrt(i))
factors <- primenums[which(i %% primenums == 0)]
while(i / prod(factors) > 1) {
newnum <- i/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
prod(mapply(function(x,y) x^y, as.numeric(names(df)), sapply(df, max)))
}
euler_five()
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 1:n){
primenums <- primes(sqrt(i))
factors <- primenums[which(i %% primenums == 0)]
while(i / prod(factors) > 1) {
newnum <- i/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
prod(mapply(function(x,y) x^y, as.numeric(names(df)), sapply(df, max)))
}
euler_five()
# PROJECT EULER EXERCISE 5:
#
# 2520 is the smallest number that can be divided by each of the numbers
# from 1 to 10 without any remainder.
#
# What is the smallest positive number that is evenly divisible by all
# of the numbers from 1 to 20?
primes <- function(n) {
n <- floor(n)
primes <- c(FALSE, rep(TRUE, n-1))
max_p <- floor(sqrt(n))
p <- 2L
while(p <= max_p) {
primes[seq.int(2L*p, n, p)] <- FALSE
p <- min(subset(which(primes), which(primes) > p))
}
which(primes)
}
euler_five <- function(n = 20) {
names <- primes(n)
df <- data.frame(matrix(nrow = 0, ncol = length(names)))
names(df) <- names
for(i in 1:n){
primenums <- primes(sqrt(i))
factors <- primenums[which(i %% primenums == 0)]
while(i / prod(factors) > 1) {
newnum <- i/prod(factors)
primenums <- primes(sqrt(newnum))
newfactors <- primenums[which(newnum %% primenums == 0)]
if(length(newfactors) == 0) {
factors <- c(factors, newnum)
} else factors <- c(factors, newfactors)
}
df[i,] <- sapply(names, function(x) sum(sort(factors) == x))
}
prod(mapply(function(x,y) x^y, as.numeric(names(df)), sapply(df, max)))
}
euler_five()
euler_five(100)
euler_five(1000)
euler_five(100)
euler_five()
